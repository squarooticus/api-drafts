<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>An Architecture for Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font: 13.5px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Overview">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Event-Driven API">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Data Transfer Using Messages">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Flexibile Implementation">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Specification of Requirements">
<link href="#rfc.section.3" rel="Chapter" title="3 Design Principles">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Common APIs for Common Features">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Access to Specialized Features">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Scope for API and Implementation Definitions">
<link href="#rfc.section.4" rel="Chapter" title="4 Transport Services Architecture and Concepts">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Transport Services API Concepts">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Basic Objects">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Pre-Establishment">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Establishment Actions">
<link href="#rfc.section.4.1.4" rel="Chapter" title="4.1.4 Data Transfer Objects and Actions">
<link href="#rfc.section.4.1.5" rel="Chapter" title="4.1.5 Event Handling">
<link href="#rfc.section.4.1.6" rel="Chapter" title="4.1.6 Termination Actions">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Transport System Implementation Concepts">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Candidate Gathering">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Candidate Racing">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Protocol Stack Equivalence">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="8 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.16.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Pauly, T., Ed., Trammell, B., Ed., Brunstrom, A., Fairhurst, G., Perkins, C., Tiesel, P., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-taps-arch-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-01-04" />
  <meta name="dct.abstract" content="This document provides an overview of the architecture of Transport Services, a model for exposing transport protocol features to applications for network communication. In contrast to what is provided by most existing Application Programming Interfaces (APIs), it is based on an asynchronous, event-driven interaction pattern; it uses messages for representing data transfer to applications; and it assumes an implementation that can use multiple IP addresses, multiple protocols, multiple paths, and provide multiple application streams. This document further defines the common set of terminology and concepts to be used in definitions of APIs and implementations." />
  <meta name="description" content="This document provides an overview of the architecture of Transport Services, a model for exposing transport protocol features to applications for network communication. In contrast to what is provided by most existing Application Programming Interfaces (APIs), it is based on an asynchronous, event-driven interaction pattern; it uses messages for representing data transfer to applications; and it assumes an implementation that can use multiple IP addresses, multiple protocols, multiple paths, and provide multiple application streams. This document further defines the common set of terminology and concepts to be used in definitions of APIs and implementations." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">T. Pauly, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
<td class="left">Expires: July 8, 2019</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">A. Brunstrom</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Karlstad University</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">January 04, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">An Architecture for Transport Services<br />
  <span class="filename">draft-ietf-taps-arch-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document provides an overview of the architecture of Transport Services, a model for exposing transport protocol features to applications for network communication. In contrast to what is provided by most existing Application Programming Interfaces (APIs), it is based on an asynchronous, event-driven interaction pattern; it uses messages for representing data transfer to applications; and it assumes an implementation that can use multiple IP addresses, multiple protocols, multiple paths, and provide multiple application streams. This document further defines the common set of terminology and concepts to be used in definitions of APIs and implementations.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 8, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Overview</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Event-Driven API</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Data Transfer Using Messages</a>
</li>
<li>1.4.   <a href="#rfc.section.1.4">Flexibile Implementation</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Specification of Requirements</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Design Principles</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Common APIs for Common Features</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Access to Specialized Features</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Scope for API and Implementation Definitions</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Transport Services Architecture and Concepts</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Transport Services API Concepts</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Basic Objects</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Pre-Establishment</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">Establishment Actions</a>
</li>
<li>4.1.4.   <a href="#rfc.section.4.1.4">Data Transfer Objects and Actions</a>
</li>
<li>4.1.5.   <a href="#rfc.section.4.1.5">Event Handling</a>
</li>
<li>4.1.6.   <a href="#rfc.section.4.1.6">Termination Actions</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Transport System Implementation Concepts</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Candidate Gathering</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Candidate Racing</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Protocol Stack Equivalence</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.references">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Many application programming interfaces (APIs) to perform transport networking have been deployed, perhaps the most widely known and imitated being the BSD socket() <a href="#POSIX" class="xref">[POSIX]</a> interface. The names and functions between these APIs are not consistent, and vary depending on the protocol being used. For example, sending and receiving on a stream of data is conceptually the same between operating on an unencrypted Transmission Control Protocol (TCP) stream and operating on an encrypted Transport Layer Security (TLS) <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> stream over TCP, but applications cannot use the same socket send() and recv() calls on top of both kinds of connections. Similarly, terminology for the implementation of protocols offering transport services vary based on the context of the protocols themselves. This variety can lead to confusion when trying to understand the similarities and differences between protocols, and how applications can use them effectively.</p>
<p id="rfc.section.1.p.2">The goal of the Transport Services architecture is to provide a common, flexible, and reusable interface for transport protocols. As applications adopt this interface, they will benefit from a wide set of transport features that can evolve over time, and ensure that the system providing the interface can optimize its behavior based on the application requirements and network conditions, without requiring a change to the application. Further, this flexibility does not only enable faster deployment of new feature and protocols, it can also support applications with racing and fallback mechanisms which today usually need to be implemented in each application separately.</p>
<p id="rfc.section.1.p.3">This document is developed in parallel with the specification of the Transport Services API <a href="#I-D.ietf-taps-interface" class="xref">[I-D.ietf-taps-interface]</a> and Implementation <a href="#I-D.ietf-taps-impl" class="xref">[I-D.ietf-taps-impl]</a> documents. Although following the Transport Services Architecture does of course not mean that all APIs and implementations have to be identical, agreeing on a common minimal set of features and representing them in a similar fashion improves the ability to easily port applications from one system to the another.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.1.1.p.1">The model for using sockets for networking can be represented as follows: applications create connections and transfer data using the socket API, which provides the interface to the implementations of UDP and TCP (typically implemented in the system&#8217;s kernel), which in turn send data over the available network layer interfaces.</p>
<pre>
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
           |                             |
+---------------------+       +-----------------------+
|  Socket Stream API  |       |  Socket Datagram API  |
+---------------------+       +-----------------------+
           |                             |
+-----------------------------------------------------+
|         TCP                           UDP           |
|           Kernel Protocol Implementation            |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+

</pre>
<p id="rfc.section.1.1.p.2">The Transport Services architecture maintains this general model of interaction, but aims to both modernize the API surface exposed for transport protocols and enrich the capabilities of the transport system implementation.</p>
<pre>
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|               Transport Services API                |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|           Transport System Implementation           |
|       (UDP, TCP, SCTP, DCCP, TLS, QUIC, etc)        |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+

</pre>
<p id="rfc.section.1.1.p.3">The Transport Services API <a href="#I-D.ietf-taps-interface" class="xref">[I-D.ietf-taps-interface]</a> defines the mechanism for an application to create and monitor network connections, and transfer data. The Implementation <a href="#I-D.ietf-taps-impl" class="xref">[I-D.ietf-taps-impl]</a> is responsible for mapping the API into the various available transport protocols and managing the available network interfaces and paths.</p>
<p id="rfc.section.1.1.p.4">There are a few key departures that Transport Services makes from the sockets API: it presents an asynchronous, event-driven API; it uses messages for representing data transfer to applications; and it assumes an implementation that can use multiple IP addresses, multiple protocols, multiple paths, and provide multiple application streams.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#event-driven-api" id="event-driven-api">Event-Driven API</a>
</h1>
<p id="rfc.section.1.2.p.1">Originally, sockets presented a blocking interface for establishing connections and transferring data. However, most modern applications interact with the network asynchronously. When sockets are presented as an asynchronous interface, they generally use a try-and-fail model. If the application wants to read, but data has not yet been received from the peer, the call to read will fail. The application then waits and can try again later.</p>
<p id="rfc.section.1.2.p.2">All interaction with a Transport Services system is expected to be asynchronous, and use an event-driven model unlike sockets <a href="#events" class="xref">Section 4.1.5</a>. For example, if the application wants to read, its call to read will not fail, but will deliver an event containing the received data once it is available.</p>
<p id="rfc.section.1.2.p.3">The Transport Services API also delivers events regarding the lifetime of a connection and changes to available network links, which were not previously made explicit in sockets.</p>
<p id="rfc.section.1.2.p.4">Using asynchronous events allows for a much simpler interaction model when establishing connections and transferring data. Events in time more closely reflect the nature of interactions over networks, as opposed to how sockets represent network resources as file system objects that may be temporarily unavailable.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#data-transfer-using-messages" id="data-transfer-using-messages">Data Transfer Using Messages</a>
</h1>
<p id="rfc.section.1.3.p.1">Sockets provide a message interface for datagram protocols like UDP, but provide an unstructured stream abstraction for TCP. While TCP does indeed provide the ability to send and receive data as streams, most applications need to interpret structure within these streams. HTTP/1.1 uses character delimiters to segment messages over a stream; TLS record headers carry a version, content type, and length; and HTTP/2 uses frames to segment its headers and bodies.</p>
<p id="rfc.section.1.3.p.2">The Transport Services API respresents data as messages, so that it more closely matches the way applications use the network. Messages seamlessly work with transport protocols that support datagrams or records, but can also be used over a stream by defining an application-layer framer to use <a href="#datatransfer" class="xref">Section 4.1.4</a>. When framing protocols are placed on top of unstructured streams, the messages used in the API represent the framed messages within the stream. In the absence of a framer, protocols that deal only in byte streams, such as TCP, represent their data in each direction as a single, long message.</p>
<p id="rfc.section.1.3.p.3">Providing a message-based abstraction provides many benefits, such as:</p>
<p></p>

<ul>
<li>the ability to associate deadlines with messages, for applications that care about timing;</li>
<li>the ability to provide control of reliability, choosing which messages to retransmit in the event of packet loss, and how best to make use of the data that arrived;</li>
<li>the ability to manage dependencies between messages, when the transport system could decide to not deliver a message, either following packet loss or because it has missed a deadline. In particular, this can avoid (re-)sending data that relies on a previous transmission that was never received.</li>
</ul>
<p id="rfc.section.1.3.p.5">Allowing applications to interact with messages is backwards-compatible with existings protocols and APIs, as it does not change the wire format of any protocol. Instead, it gives the protocol stack additional information to allow it to make better use of modern transport services, while simplifying the application&#8217;s role in parsing data.</p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> <a href="#flexibile-implementation" id="flexibile-implementation">Flexibile Implementation</a>
</h1>
<p id="rfc.section.1.4.p.1">Sockets, for protocols like TCP, are generally limited to connecting to a single address over a single interface. They also present a single stream to the application. Software layers built upon sockets often propagate this limitation of a single-address single-stream model. The Transport Services architecture is designed to handle multiple candidate endpoints, protocols, and paths; and support multipath and multistreaming protocols.</p>
<p id="rfc.section.1.4.p.2">Transport Services implementations are meant to be flexible at connection establishment time, considering many different options and trying to select the most optimal combinations (<a href="#gathering" class="xref">Section 4.2.1</a> and <a href="#racing" class="xref">Section 4.2.2</a>). This requires applications to provide higher-level endpoints than IP addresses, such as hostnames and URLs, which are used by a Transport Services implementation for resolution, path selection, and racing.</p>
<p id="rfc.section.1.4.p.3">Flexibility after connection establishment is also important. Transport protocols that can migrate between multiple network layer interfaces need to be able to process and react to interface changes. Protocols that support multiple application-layer streams need to support initiating and receiving new streams using existing connections.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<p id="rfc.section.2.p.1">The Transport Services architecture is based on the survey of Services Provided by IETF Transport Protocols and Congestion Control Mechanisms <a href="#RFC8095" class="xref">[RFC8095]</a>, and the distilled minimal set of the features offered by transport protocols <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>. This work has identified common features and patterns across all transport protocols developed thus far in the IETF.</p>
<p id="rfc.section.2.p.2">Since transport security is an increasingly relevant aspect of using transport protocols on the Internet, this architecture also considers the impact of transport security protocols on the feature set exposed by transport services <a href="#I-D.ietf-taps-transport-security" class="xref">[I-D.ietf-taps-transport-security]</a>.</p>
<p id="rfc.section.2.p.3">One of the key insights to come from identifying the minimal set of features provided by transport protocols <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a> was that features either require application interaction and guidance (referred to as Functional Features), or else can be handled automatically by a system implementing Transport Services (referred to as Automatable Features). Among the Functional Features, some were common across all or nearly all transport protocols, while others could be seen as features that, if specified, would only be useful with a subset of protocols, or perhaps even a single transport protocol, but would not harm the functionality of other protocols. For example, some protocols can deliver messages faster for applications that do not require them to arrive in the order in which they were sent. However, this functionality needs to be explicitly allowed by the application, since reordering messages would be undesirable in many cases.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#specification-of-requirements" id="specification-of-requirements">Specification of Requirements</a>
</h1>
<p id="rfc.section.2.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#design-principles" id="design-principles">Design Principles</a>
</h1>
<p id="rfc.section.3.p.1">The goal of the Transport Services architecture is to redefine the interface between applications and transports in a way that allows the transport layer to evolve and improve without fundamentally changing the contract with the application. This requires a careful consideration of how to expose the capabilities of protocols.</p>
<p id="rfc.section.3.p.2">There are several degrees in which a Transport Services system can offer flexibility to an application: it can provide access to multiple sets of protocols and protocol features, it can use these protocols across multiple paths that could have different performance and functional characteristics, and it can communicate with different remote systems to optimize performance, robustness to failure, or some other metric. Beyond these, if the API for the system remains the same over time, new protocols and features could be added to the system&#8217;s implementation without requiring changes in applications for adoption.</p>
<p id="rfc.section.3.p.3">The following considerations were used in the design of this architecture.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#common-apis-for-common-features" id="common-apis-for-common-features">Common APIs for Common Features</a>
</h1>
<p id="rfc.section.3.1.p.1">Functionality that is common across multiple transport protocols SHOULD be accessible through a unified set of API calls. An application ought to be able to implement logic for its basic use of transport networking (establishing the transport, and sending and receiving data) once, and expect that implementation to continue to function as the transports change.</p>
<p id="rfc.section.3.1.p.2">Any Transport Services API is REQUIRED to allow access to the distilled minimal set of features offered by transport protocols <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#access-to-specialized-features" id="access-to-specialized-features">Access to Specialized Features</a>
</h1>
<p id="rfc.section.3.2.p.1">There are applications that will need to control fine-grained details of transport protocols to optimize their behavior and ensure compatibility with remote systems. A Transport Services system therefore SHOULD also permit more specialized protocol features to be used. The interface for these specialized options should be exposed differently from the common options to ensure flexibility.</p>
<p id="rfc.section.3.2.p.2">A specialized feature could be required by an application only when using a specific protocol, and not when using others. For example, if an application is using UDP, it could require control over the checksum or fragmentation behavior for UDP; if it used a protocol to frame its data over a byte stream like TCP, it would not need these options. In such cases, the API ought to expose the features in such a way that they take effect when a particular protocol is selected, but do not imply that only that protocol could be used. For example, if the API allows an application to specify a preference for constrained checksum usage, communication would not fail when a protocol such as TCP is selected, which uses a checksum covering the entire payload.</p>
<p id="rfc.section.3.2.p.3">Other specialized features, however, could be strictly required by an application and thus constrain the set of protocols that can be used. For example, if an application requires encryption of its transport data, only protocol stacks that include some transport security protocol are eligible to be used. A Transport Services API MUST allow applications to define such requirements and constrain the system&#8217;s options. Since such options are not part of the core/common features, it will generally be simple for an application to modify its set of constraints and change the set of allowable protocol features without changing the core implementation.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#scope-for-api-and-implementation-definitions" id="scope-for-api-and-implementation-definitions">Scope for API and Implementation Definitions</a>
</h1>
<p id="rfc.section.3.3.p.1">The Transport Services API is envisioned as the abstract model for a family of APIs that share a common way to expose transport features and encourage flexibility. The abstract API definition <a href="#I-D.ietf-taps-interface" class="xref">[I-D.ietf-taps-interface]</a> describes this interface and is aimed at application developers.</p>
<p id="rfc.section.3.3.p.2">Implementations that provide the Transport Services API <a href="#I-D.ietf-taps-impl" class="xref">[I-D.ietf-taps-impl]</a> will vary due to system-specific support and the needs of the deployment scenario. It is expected that all implementations of Transport Services will offer the entire mandatory API, but that some features will not be functional in certain implementations. All implementations are REQUIRED to offer sufficient APIs to use the distilled minimal set of features offered by transport protocols <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>, including API support for TCP and UDP transport, but it is possible that some very constrained devices might not have, for example, a full TCP implementation beneath the API.</p>
<p id="rfc.section.3.3.p.3">To preserve flexibility and compatibility with future protocols, top-level features in the Transport Services API SHOULD avoid referencing particular transport protocols. The mappings of these API features to specific implementations of each feature is explained in the <a href="#I-D.ietf-taps-impl" class="xref">[I-D.ietf-taps-impl]</a> which also explain the implications of the feature provided by existing protocols. It is expected that this document will be updated and supplemented as new protocols and protocol features are developed.</p>
<p id="rfc.section.3.3.p.4">It is important to note that neither the Transport Services API <a href="#I-D.ietf-taps-interface" class="xref">[I-D.ietf-taps-interface]</a> nor the Implementation document <a href="#I-D.ietf-taps-impl" class="xref">[I-D.ietf-taps-impl]</a> defines new protocols that require any changes to a remote system. The Transport Services system MUST be deployable on one side only, as a way to allow an application to make better use of available capabilities on a system and protocol features that may be supported by peers across the network.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#transport-services-architecture-and-concepts" id="transport-services-architecture-and-concepts">Transport Services Architecture and Concepts</a>
</h1>
<p id="rfc.section.4.p.1">The concepts defined in this document are intended primarily for use in the documents and specifications that describe the Transport Services architecture and API. While the specific terminology can be used in some implementations, it is expected that there will remain a variety of terms used by running code.</p>
<p id="rfc.section.4.p.2">The architecture divides the concepts for Transport Services into two categories:</p>
<p></p>

<ol>
<li>API concepts, which are intended to be exposed to applications; and</li>
<li>System-implementation concepts, which are intended to be internally used when building systems that implement Transport Services.</li>
</ol>
<p id="rfc.section.4.p.4">The following diagram summarizes the top-level concepts in the architecture and how they relate to one another.</p>
<div id="rfc.figure.1"></div>
<div id="fig-abstractions"></div>
<pre>
  +-----------------------------------------------------+
  |                    Application                      |
  +-+----------------+------^-------+--------^----------+
    |                |      |       |        |
  pre-               |     data     |      events
  establishment      |   transfer   |        |
    |        establishment  |   termination  |
    |                |      |       |        |
    |             +--v------v-------v+       |
  +-v-------------+   Connection(s)  +-------+----------+
  |  Transport    +--------+---------+                  |
  |  Services              |                            |
  |  API                   |                            |
  +------------------------|----------------------------+
                           |
  +------------------------|----------------------------+
  |  Transport             |                            |
  |  System                |        +-----------------+ |
  |  Implementation        |        |     Cached      | |
  |                        |        |      State      | |
  |  (Candidate Gathering) |        +-----------------+ |
  |                        |                            |
  |  (Candidate Racing)    |        +-----------------+ |
  |                        |        |     System      | |
  |                        |        |     Policy      | |
  |             +----------v-----+  +-----------------+ |
  |             |    Protocol    |                      |
  +-------------+    Stack(s)    +----------------------+
                +-------+--------+
                        V
              Network Layer Interface
</pre>
<p class="figure">Figure 1: Concepts and Relationships in the Transport Services Architecture</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#transport-services-api-concepts" id="transport-services-api-concepts">Transport Services API Concepts</a>
</h1>
<p id="rfc.section.4.1.p.1">Fundamentally, a Transport Services API needs to provide basic objects (<a href="#objects" class="xref">Section 4.1.1</a>) that allow applications to establish communication and send and receive data. These could be exposed as handles or referenced objects, depending on the language.</p>
<p id="rfc.section.4.1.p.2">Beyond the basic objects, there are several high-level groups of actions that any Transport Services API implementing this specification MUST provide:</p>
<p></p>

<ul>
<li>Pre-Establishment (<a href="#preestablishment" class="xref">Section 4.1.2</a>) encompasses the properties that an application can pass to describe its intent, requirements, prohibitions, and preferences for its networking operations. For any system that provides generic Transport Services, these properties SHOULD be defined to apply to multiple transport protocols. Some properties are specific to a single transport protocol, and these are be exposed as non-generic interfaces (see Specific Protocol Properties <a href="#preestablishment" class="xref">Section 4.1.2</a>). Properties can have a large impact on the rest of the aspects of the interface: they modify how establishment occurs, they influence the expectations around data transfer, and they determine the set of events that will be supported.</li>
<li>Establishment (<a href="#establishment" class="xref">Section 4.1.3</a>) focuses on the actions that an application takes on the basic objects to prepare for data transfer.</li>
<li>Data Transfer (<a href="#datatransfer" class="xref">Section 4.1.4</a>) consists of how an application represents the data to be sent and received, the functions required to send and receive that data, and how the application is notified of the status of its data transfer.</li>
<li>Event Handling (<a href="#events" class="xref">Section 4.1.5</a>) defines the set of properties about which an application can receive notifications during the lifetime of transport objects. Events MAY also provide opportunities for the application to interact with the underlying transport by querying state or updating maintenance options.</li>
<li>Termination (<a href="#termination" class="xref">Section 4.1.6</a>) focuses on the methods by which data transmission is stopped, and state is torn down in the transport.</li>
</ul>
<p id="rfc.section.4.1.p.4">The diagram below provides a high-level view of the actions taken during the lifetime of a connection.</p>
<div id="rfc.figure.2"></div>
<div id="fig-lifetime"></div>
<pre>
     Pre-Establishment     :       Established             : Termination
     -----------------     :       -----------             : -----------
                           :                     Close()   :
     +---------------+ Initiate() +------------+ Abort()   :
 +--&gt;| Preconnection |-----------&gt;| Connection |---------------&gt; Closed
 |   +---------------+     :      +------------+ Connection:
 |                         :      ^   ^    |     Finished  :
 +-- Local Endpoint        :      |   |    |               :
 |                         :      |   |    +---------+     :
 +-- Remote Endpoint       :      |   |              |     :
 |                         :      |   |Send()        |     :
 +-- Path Selection        :      | +---------+      v     :
 |   Properties            :      | | Message |  Message   :
 |                         :      | | to send |  Received  :
 +-- Protocol Selection    :      | +---------+            :
 |   Properties            :      |                        :
 |                         :      |                        :
 +-- Specific Protocol     :      |                        :
 |   Properties            :      |                        :
 |                         :      |                        :
 |   +----------+          :      |                        :
 +--&gt;| Listener |-----------------+                        :
     +----------+ Connection Received                      :
           ^               :                               :
           |               :                               :
        Listen()           :                               :
</pre>
<p class="figure">Figure 2: The lifetime of a connection</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#objects" id="objects">Basic Objects</a>
</h1>
<p></p>

<ul>
<li>Preconnection: A Preconnection object is a representation of a potential connection. It has state that describes parameters of a Connection that might exist in the future: the Local Endpoint from which that Connection will be established, the Remote Endpoint (<a href="#preestablishment" class="xref">Section 4.1.2</a>) to which it will connect, and Path Selection Properties, Protocol Selection Properties, and Specific Protocol Properties that influence the choice of transport that a Connection will use. A Preconnection can be fully specified and represent a single possible Connection, or it can be partially specified such that it represents a family of possible Connections. The Local Endpoint (<a href="#preestablishment" class="xref">Section 4.1.2</a>) MUST be specified if the Preconnection is used to Listen for incoming connections. The Local Endpoint is OPTIONAL if it is used to Initiate connections. The Remote Endpoint MUST be specified in the Preconnection is used to Initiate connections. The Remote Endpoint is OPTIONAL if it is used to Listen for incoming connections. The Local Endpoint and the Remote Endpoint MUST both be specified if a peer-to-peer Rendezvous is to occur based on the Preconnection.</li>
<li>Connection: A Connection object represents an active transport protocol instance that can send and/or receive Messages between local and remote systems. It holds state pertaining to the underlying transport protocol instance and any ongoing data transfer. This represents, for example, an active connection in a connection-oriented protocol such as TCP, or a fully-specified 5-tuple for a connectionless protocol such as UDP.</li>
<li>Listener: A Listener object accepts incoming transport protocol connections from remote systems  and generates corresponding Connection objects. It is created from a Preconnection object that specifies the type of incoming connections it will accept.</li>
</ul>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#preestablishment" id="preestablishment">Pre-Establishment</a>
</h1>
<p></p>

<ul>
<li>Endpoint: An Endpoint represents an identifier for one side of a transport connection.  Endpoints can be Local Endpoints or Remote Endpoints, and respectively represent an identity that the application uses for the source or destination of a connection.  An Endpoint can be specified at various levels, and an Endpoint with wider scope (such as a hostname) can be resolved to more concrete identities (such as IP addresses).</li>
<li>Remote Endpoint: The Remote Endpoint represents the application&#8217;s identifier for a peer that can participate in a transport connection. For example, the combination of a DNS name for the peer and a service name/port.</li>
<li>Local Endpoint: The Local Endpoint represents the application&#8217;s identifier for itself that it uses for transport connections. For example, a local IP address and port.</li>
<li>Path Selection Properties: The Path Selection Properties consist of the options that an application can set to influence the selection of paths between the local and remote systems. These options can take  the form of requirements, prohibitions, or preferences. Examples of options that influence path selection include the interface type (such as a Wi-Fi Ethernet connection, or a Cellular LTE connection), characteristics of the path that are locally known like the Maximum Transmission Unit (MTU) or discovered like the Path MTU (PMTU), or predicted based on cached information like expected throughput or latency.</li>
<li>Protocol Selection Properties: The Protocol Selection Properties consist of the options that an application can set to influence the selection of transport protocol, or to configure the behavior of generic transport protocol features. These options can take the form of requirements, prohibitions, and preferences. Examples include reliability, service class, multipath support, and fast open support.</li>
<li>Specific Protocol Properties: The Specific Protocol Properties refer to the subset of Protocol Properties options that apply to a single protocol (transport protocol, IP, or security protocol). The presence of such Properties does not require that a specific protocol will be used when a Connection is established, but that if this protocol is employed, a particular set of options is to be used.</li>
</ul>
<h1 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#establishment" id="establishment">Establishment Actions</a>
</h1>
<p></p>

<ul>
<li>Initiate: The primary action that an application can take to create a Connection to a Remote Endpoint, and prepare any required local or remote state to be able to send and/or receive Messages. For some protocols, this will initiate a client-to-server style handshake; for other protocols, this will just establish local state. The process of identifying options for connecting, such as resolution of the Remote Endpoint, occurs in response the Initiate call.</li>
<li>Listen: The action of marking a Listener as willing to accept incoming Connections. The Listener will then create Connection objects as incoming connections are accepted (<a href="#events" class="xref">Section 4.1.5</a>).</li>
<li>Rendezvous: The action of establishing a peer-to-peer connection with a Remote Endpoint. It simultaneously attempts to initiate a connection to a Remote Endpoint whilst listening for an incoming connection from that endpoint. This corresponds, for example, to a TCP simultaneous open <a href="#RFC0793" class="xref">[RFC0793]</a>. The process of identifying options for the connection, such as resolution of the Remote Endpoint, occurs during the Rendezvous call. If successful, the rendezvous call returns a Connection object to represent the established peer-to-peer connection.</li>
</ul>
<h1 id="rfc.section.4.1.4">
<a href="#rfc.section.4.1.4">4.1.4.</a> <a href="#datatransfer" id="datatransfer">Data Transfer Objects and Actions</a>
</h1>
<p></p>

<ul>
<li>Message: A Message object is a unit of data that can be represented as bytes that can be transferred between two systems over a transport connection. The bytes within a Message are assumed to be ordered within the Message. If an application does not care about the order in which a peer receives two distinct spans of bytes, those spans of bytes are considered independent Messages. If a received Message is incomplete or corrupted, it might or might not be usable by certain applications. Boundaries of a Message might or might not be understood or transmitted by transport protocols. Specifically, what one application considers to be two Messages sent on a stream-based transport can be treated as a single Message by the application on the other side.</li>
<li>Send: The action to transmit a Message or partial Message over a Connection to the remote system. The interface to Send MAY include options specific to how the Message&#8217;s content is to be sent. Status of the Send operation can be delivered back to the application in an event (<a href="#events" class="xref">Section 4.1.5</a>).</li>
<li>Receive: An action that indicates that the application is ready to asynchronously accept a Message over a Connection from a remote system, while the Message content itself will be delivered in an event (<a href="#events" class="xref">Section 4.1.5</a>). The interface to Receive MAY include options specific to the Message that is to be delivered to the application.</li>
<li>Framer: A Framer is a data translation layer that can be added to a Connection to define how application-level Messages are transmitted over a transport protocol. This is particularly relevant for protocols that otherwise present unstructured streams, such as TCP.</li>
</ul>
<h1 id="rfc.section.4.1.5">
<a href="#rfc.section.4.1.5">4.1.5.</a> <a href="#events" id="events">Event Handling</a>
</h1>
<p id="rfc.section.4.1.5.p.1">This list of events that can be delivered to an application is not exhaustive, but gives the top-level categories of events. The API MAY expand this list.</p>
<p></p>

<ul>
<li>Connection Ready: Signals to an application that a given Connection is ready to send and/or receive Messages. If the Connection relies on handshakes to establish state between peers, then it is assumed that these steps have been taken.</li>
<li>Connection Finished: Signals to an application that a given Connection is no longer usable for sending or receiving Messages. The event SHOULD deliver a reason or error to the application that describes the nature of the termination.</li>
<li>Connection Received: Signals to an application that a given Listener has passively received a Connection.</li>
<li>Message Received: Delivers received Message content to the application, based on a Receive action. This MAY include an error if the Receive action cannot be satisfied due to the Connection being closed.</li>
<li>Message Sent: Notifies the application of the status of its Send action. This might indicate a failure if the Message cannot be sent, or an indication that Message has been processed by the protocol stack.</li>
<li>Path Properties Changed: Notifies the application that some property of the Connection has changed that might influence how and where data is sent and/or received.</li>
</ul>
<h1 id="rfc.section.4.1.6">
<a href="#rfc.section.4.1.6">4.1.6.</a> <a href="#termination" id="termination">Termination Actions</a>
</h1>
<p></p>

<ul>
<li>Close: The action an application takes on a Connection to indicate that it no longer intends to send data, is no longer willing to receive data, and that the protocol SHOULD signal this state to the remote system if the transport protocol allows this.</li>
<li>Abort: The action the application takes on a Connection to indicate a Close and also indicate that the transport system SHOULD NOT attempt to deliver any outstanding data.</li>
</ul>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#transport-system-implementation-concepts" id="transport-system-implementation-concepts">Transport System Implementation Concepts</a>
</h1>
<p id="rfc.section.4.2.p.1">The Transport System Implementation Concepts define the set of objects used internally to a system or library to implement the functionality needed to provide a transport service across a network, as required by the abstract interface.</p>
<p></p>

<ul>
<li>Connection Group: A set of Connections that share properties. For multiplexing transport protocols, the Connection Group defines the set of Connections that can be multiplexed together.</li>
<li>Path: Represents an available set of properties that a local system can use to communicate with a remote system, such as routes, addresses, and physical and virtual network interfaces.</li>
<li>Protocol Instance: A single instance of one protocol, including any state it has necessary to establish connectivity or send and receive Messages.</li>
<li>Protocol Stack: A set of Protocol Instances (including relevant application, security, transport, or Internet protocols) that are used together to establish connectivity or send and receive Messages. A single stack can be simple (a single transport protocol instance over IP), or complex (multiple application protocol streams going through a single security and transport protocol, over IP; or, a multi-path transport protocol over multiple transport sub-flows).</li>
<li>Candidate Path: One path that is available to an application and conforms to the Path Selection Properties and System Policy. Candidate Paths are identified during the gathering phase (<a href="#gathering" class="xref">Section 4.2.1</a>) and can be used during the racing phase (<a href="#racing" class="xref">Section 4.2.2</a>).</li>
<li>Candidate Protocol Stack: One protocol stack that can be used by an application for a connection, of which there can be several. Candidate Protocol Stacks are identified during the gathering phase (<a href="#gathering" class="xref">Section 4.2.1</a>) and are started during the racing phase (<a href="#racing" class="xref">Section 4.2.2</a>).</li>
<li>System Policy: Represents the input from an operating system or other global preferences that can constrain or influence how an implementation will gather candidate paths and protocol stacks (<a href="#gathering" class="xref">Section 4.2.1</a>) and race the candidates during establishment (<a href="#racing" class="xref">Section 4.2.2</a>). Specific aspects of the System Policy either apply to all Connections or only certain ones, depending on the runtime context and properties of the Connection.</li>
<li>Cached State: The state and history that the implementation keeps for each set of associated Endpoints that have been used previously. This can include DNS results, TLS session state, previous success and quality of transport protocols over certain paths.</li>
</ul>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#gathering" id="gathering">Candidate Gathering</a>
</h1>
<p></p>

<ul>
<li>Path Selection: Path Selection represents the act of choosing one or more paths that are available to use based on the Path Selection Properties provided by the application, the policies and heuristics of a Transport Services system.</li>
<li>Protocol Selection: Protocol Selection represents the act of choosing one or more sets of protocol options that are available to use based on the Protocol Properties provided by the application, and a Transport Services system&#8217;s policies and heuristics.</li>
</ul>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#racing" id="racing">Candidate Racing</a>
</h1>
<p></p>

<ul>
<li>Protocol Option Racing: Protocol Racing is the act of attempting to establish, or scheduling attempts to establish, multiple Protocol Stacks that differ based on the composition of protocols or the options used for protocols.</li>
<li>Path Racing: Path Racing is the act of attempting to establish, or scheduling attempts to establish, multiple Protocol Stacks that differ based on a selection from the available Paths. Since different Paths will have distinct configurations for local addresses and DNS servers, attempts across different Paths will perform separate DNS resolution stepss, which can lead to further racing of the resolved Remote Endpoints.</li>
<li>Remote Endpoint Racing: Remote Endpoint Racing is the act of attempting to establish, or scheduling attempts to establish, multiple Protocol Stacks that differ based on the specific representation of the Remote Endpoint, such as IP addresses resolved from a DNS hostname.</li>
</ul>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#equivalence" id="equivalence">Protocol Stack Equivalence</a>
</h1>
<p id="rfc.section.4.2.3.p.1">The Transport Services architecture defines a mechanism that allows applications to easily use different network paths and Protocol Stacks. Transitioning between different Protocol Stacks is in some cases controlled by properties that only change when application code is updated. For example, an application can enable the use of a multipath or multistreaming transport protocol by modifying the properties in its Pre-Connection configuration. In some cases, however, the Transport Services system will be able to automatically change Protocol Stacks without an update to the application, either by selecting a new stack entirely, or by racing multiple candidate Protocol Stacks during connection establishment. This functionality can be a powerful driver of new protocol adoption, but needs to be constrained carefully to avoid unexpected behavior that can lead to functional or security problems.</p>
<p id="rfc.section.4.2.3.p.2">If two different Protocol Stacks can be safely swapped, or raced in parallel (see <a href="#racing" class="xref">Section 4.2.2</a>), then they are considered to be &#8220;equivalent&#8221;. Equivalent Protocol Stacks need to meet the following criteria:</p>
<p></p>

<ol>
<li>Both stacks MUST offer the same interface to the application for connection establishment and data transmission. For example, if one Protocol Stack has UDP as the top-level interface to the application, then it is not equivalent to a Protocol Stack that runs TCP as the top-level interface. Among other differences, the UDP stack would allow an application to read out message boundaries based on datagrams sent from the remote system, whereas TCP does not preserve message boundaries on its own.</li>
<li>Both stacks MUST offer the same transport services, as required by the application. For example, if an application specifies that it requires reliable transmission of data, then a Protocol Stack using UDP without any reliability layer on top would not be allowed to replace a Protocol Stack using TCP. However, if the application does not require reliability, then a Protocol Stack that adds unnecessary reliability might be allowed as an equivalent Protocol Stack as long as it does not conflict with any other application-requested properties.</li>
<li>Both stacks MUST offer the same security properties. The inclusion of transport security protocols <a href="#I-D.ietf-taps-transport-security" class="xref">[I-D.ietf-taps-transport-security]</a> in a Protocol Stack adds additional restrictions to Protocol Stack equivalence. Security features and properties, such as cryptographic algorithms, peer authentication, and identity privacy vary across security protocols, and across versions of security protocols. Protocol equivalence ought not to be assumed for different protocols or protocol versions, even if they offer similar application configuration options. To ensure that security protocols are not incorrectly swapped, Transport Services systems SHOULD only automatically generate equivalent Protocol Stacks when the transport security protocols within the stacks are identical. Specifically, a transport system would consider protocols identical only if they are of the same type and version. For example, the same version of TLS running over two different transport protocol stacks are considered equivalent, whereas TLS 1.2 and TLS 1.3 <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> are not considered equivalent.</li>
</ol>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.5.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.5.p.2">This document has no actions for IANA.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">The Transport Services architecture does not recommend use of specific security protocols or algorithms. Its goal is to offer ease of use for existing protocols by providing a generic security-related interface. Each provided interface translates to an existing protocol-specific interface provided by supported security protocols. For example, trust verification callbacks are common parts of TLS APIs. Transport Services APIs will expose similar functionality <a href="#I-D.ietf-taps-transport-security" class="xref">[I-D.ietf-taps-transport-security]</a>.</p>
<p id="rfc.section.6.p.2">As described above in <a href="#equivalence" class="xref">Section 4.2.3</a>, if a Transport Services system races between two different Protocol Stacks, both MUST use the same security protocols and options.</p>
<p id="rfc.section.6.p.3">Clients need to ensure that security APIs are used appropriately. In cases where clients use an interface to provide sensitive keying material, e.g., access to private keys or copies of pre-shared keys (PSKs), key use needs to be validated. For example, clients ought not to use PSK material created for the Encapsulating Security Protocol (ESP, part of IPsec) <a href="#RFC4303" class="xref">[RFC4303]</a> with QUIC, and clients ought not to use private keys intended for server authentication as a keys for client authentication.</p>
<p id="rfc.section.6.p.4">Moreover, unlike certain transport features such as TCP Fast Open (TFO) <a href="#RFC7413" class="xref">[RFC7413]</a> or Explicit Congestion Notification (ECN) <a href="#RFC3168" class="xref">[RFC3168]</a> which can fall back to standard configurations, Transport Services systems MUST prohibit fallback for security protocols. For example, if a client requests TLS, yet TLS or the desired version are not available, its connection will fail. Clients are thus responsible for implementing security protocol fallback or version fallback by creating multiple Transport Services Connections, if so desired.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">This work has received funding from the European Union&#8217;s Horizon 2020 research and innovation programme under grant agreements No. 644334 (NEAT) and No. 688421 (MAMI).</p>
<p id="rfc.section.7.p.2">This work has been supported by Leibniz Prize project funds of DFG - German Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).</p>
<p id="rfc.section.7.p.3">This work has been supported by the UK Engineering and Physical Sciences Research Council under grant EP/R04144X/1.</p>
<p id="rfc.section.7.p.4">Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-taps-impl">[I-D.ietf-taps-impl]</b></td>
<td class="top">
<a>Brunstrom, A.</a>, <a>Pauly, T.</a>, <a>Enghardt, T.</a>, <a>Grinnemo, K.</a>, <a>Jones, T.</a>, <a>Tiesel, P.</a>, <a>Perkins, C.</a> and <a>M. Welzl</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-impl-02">Implementing Interfaces to Transport Services</a>", Internet-Draft draft-ietf-taps-impl-02, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-taps-interface">[I-D.ietf-taps-interface]</b></td>
<td class="top">
<a>Trammell, B.</a>, <a>Welzl, M.</a>, <a>Enghardt, T.</a>, <a>Fairhurst, G.</a>, <a>Kuehlewind, M.</a>, <a>Perkins, C.</a>, <a>Tiesel, P.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-interface-02">An Abstract Application Layer Interface to Transport Services</a>", Internet-Draft draft-ietf-taps-interface-02, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-taps-minset">[I-D.ietf-taps-minset]</b></td>
<td class="top">
<a>Welzl, M.</a> and <a>S. Gjessing</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-minset-11">A Minimal Set of Transport Services for End Systems</a>", Internet-Draft draft-ietf-taps-minset-11, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-taps-transport-security">[I-D.ietf-taps-transport-security]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Perkins, C.</a>, <a>Rose, K.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-transport-security-04">A Survey of Transport Security Protocols</a>", Internet-Draft draft-ietf-taps-transport-security-04, November 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-28">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-28, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="POSIX">[POSIX]</b></td>
<td class="top">"<a>IEEE Std. 1003.1-2008 Standard for Information Technology -- Portable Operating System Interface (POSIX).  Open group Technical Standard: Base Specifications, Issue 7</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3168">[RFC3168]</b></td>
<td class="top">
<a>Ramakrishnan, K.</a>, <a>Floyd, S.</a> and <a>D. Black</a>, "<a href="https://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>", RFC 3168, DOI 10.17487/RFC3168, September 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4303">[RFC4303]</b></td>
<td class="top">
<a>Kent, S.</a>, "<a href="https://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, DOI 10.17487/RFC4303, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7413">[RFC7413]</b></td>
<td class="top">
<a>Cheng, Y.</a>, <a>Chu, J.</a>, <a>Radhakrishnan, S.</a> and <a>A. Jain</a>, "<a href="https://tools.ietf.org/html/rfc7413">TCP Fast Open</a>", RFC 7413, DOI 10.17487/RFC7413, December 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8095">[RFC8095]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/rfc8095">Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</a>", RFC 8095, DOI 10.17487/RFC8095, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tommy Pauly</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Pauly</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tpauly@apple.com">tpauly@apple.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Anna Brunstrom</span> 
	  <span class="n hidden">
		<span class="family-name">Brunstrom</span>
	  </span>
	</span>
	<span class="org vcardline">Karlstad University</span>
	<span class="adr">
	  <span class="vcardline">Universitetsgatan 2</span>

	  <span class="vcardline">
		<span class="locality">651 88 Karlstad</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:anna.brunstrom@kau.se">anna.brunstrom@kau.se</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Godred Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  <span class="vcardline">Fraser Noble Building</span>

	  <span class="vcardline">
		<span class="locality">Aberdeen, AB24 3UE</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Scotland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

<span class="vcardline">URI: <a href="http://www.erg.abdn.ac.uk/">http://www.erg.abdn.ac.uk/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstrasse 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
